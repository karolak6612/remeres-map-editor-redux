# Copyright 2025 Alibaba Cloud
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: 'Run Qwen Code'
author: 'Alibaba Cloud'
description: |-
  Invoke the Qwen Code from a GitHub Action.

inputs:
  openai_api_key:
    description: 'The API key for Qwen Code API (DashScope compatible). Required if oauth_credentials is not provided.'
    required: false
  openai_base_url:
    description: 'The base URL for Qwen Code API endpoint.'
    required: false
    default: 'https://dashscope.aliyuncs.com/compatible-mode/v1'
  openai_model:
    description: 'The Qwen Code model to use.'
    required: false
    default: 'qwen-coder-plus-latest'
  oauth_credentials:
    description: 'OAuth credentials JSON for Qwen Code. If provided, will be written to ~/.qwen/oauth_creds.json. Mutually exclusive with openai_api_key.'
    required: false
  use_oauth:
    description: 'Whether to use OAuth authentication instead of API key. When true, oauth_credentials must be provided.'
    required: false
    default: 'false'
  qwen_cli_version:
    description: 'The version of the Qwen Code to install. Can be "latest", "preview", "nightly", a specific version number, or a git branch, tag, or commit.'
    required: false
    default: 'latest'
  qwen_debug:
    description: 'Enable debug logging and output streaming.'
    required: false
  prompt:
    description: |-
      A string passed to the Qwen Code's `--prompt` argument.
    required: false
    default: 'You are a helpful assistant.'
  settings:
    description: |-
      A JSON string written to `.qwen/settings.json` to configure the CLI's _project_ settings.
    required: false
  extensions:
    description: 'A list of Qwen Code extensions to install.'
    required: false
  upload_artifacts:
    description: 'Whether to upload artifacts to the github action.'
    required: false
    default: 'false'
  use_pnpm:
    description: 'Whether or not to use pnpm instead of npm to install qwen-code'
    required: false
    default: 'false'
  workflow_name:
    description: 'The GitHub workflow name, used for telemetry purposes.'
    required: false
    default: '${{ github.workflow }}'

outputs:
  summary:
    description: 'The summarized output from the Qwen Code execution.'
    value: '${{ steps.qwen_run.outputs.qwen_response }}'
  error:
    description: 'The error output from the Qwen Code execution, if any.'
    value: '${{ steps.qwen_run.outputs.qwen_errors }}'

runs:
  using: 'composite'
  steps:
    - name: 'Validate Inputs'
      id: 'validate_inputs'
      shell: 'bash'
      run: |-
        set -exuo pipefail

        # Emit a clear warning in three places without failing the step
        warn() {
          local msg="$1"
          echo "WARNING: ${msg}" >&2
          echo "::warning title=Input validation::${msg}"
          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            {
              echo "### Input validation warnings"
              echo
              echo "- ${msg}"
            } >> "${GITHUB_STEP_SUMMARY}"
          fi
        }

        # Validate authentication method
        auth_methods=0
        if [[ "${INPUT_OPENAI_API_KEY_PRESENT:-false}" == "true" ]]; then ((++auth_methods)); fi
        if [[ "${INPUT_USE_OAUTH:-false}" == "true" ]]; then ((++auth_methods)); fi

        if [[ "${auth_methods}" -eq 0 ]]; then
          warn "No authentication method provided. Please provide either 'openai_api_key' or set 'use_oauth' to true with 'oauth_credentials'."
        elif [[ "${auth_methods}" -gt 1 ]]; then
          warn "Multiple authentication methods provided. Please use only one of: openai_api_key or OAuth."
        fi

        # Validate OAuth credentials if OAuth is enabled
        if [[ "${INPUT_USE_OAUTH:-false}" == "true" ]] && [[ "${INPUT_OAUTH_CREDENTIALS_PRESENT:-false}" != "true" ]]; then
          warn "OAuth is enabled but no oauth_credentials provided. Please provide 'oauth_credentials'."
        fi
      env:
        INPUT_OPENAI_API_KEY_PRESENT: "${{ inputs.openai_api_key != '' }}"
        INPUT_USE_OAUTH: "${{ inputs.use_oauth }}"
        INPUT_OAUTH_CREDENTIALS_PRESENT: "${{ inputs.oauth_credentials != '' }}"

    - name: 'Sanitize workflow name'
      id: 'sanitize_workflow_name'
      shell: 'bash'
      run: |
        SANITIZED=$(echo "${WORKFLOW_NAME}" | sed 's/[^ a-zA-Z0-9-]//g' | xargs | tr ' ' '_' | tr '[:upper:]' '[:lower:]')
        echo "gh_workflow_name=$SANITIZED" >> $GITHUB_OUTPUT
      env:
        WORKFLOW_NAME: '${{ inputs.workflow_name }}'

    - name: 'Configure OAuth Credentials'
      if: |-
        ${{ inputs.use_oauth == 'true' && inputs.oauth_credentials != '' }}
      run: |-
        set -euo pipefail
        mkdir -p ~/.qwen
        echo "${OAUTH_CREDENTIALS}" > ~/.qwen/oauth_creds.json
        chmod 600 ~/.qwen/oauth_creds.json
        echo "OAuth credentials configured at ~/.qwen/oauth_creds.json"
      shell: 'bash'
      env:
        OAUTH_CREDENTIALS: '${{ inputs.oauth_credentials }}'

    - name: 'Configure Qwen Code'
      if: |-
        ${{ inputs.settings != '' }}
      run: |-
        mkdir -p .qwen/
        echo "${SETTINGS}" > ".qwen/settings.json"
      shell: 'bash'
      env:
        SETTINGS: '${{ inputs.settings }}'

    - name: 'Install Custom Commands'
      shell: 'bash'
      run: |-
        set -euo pipefail
        mkdir -p .qwen/commands
        cp -r "${GITHUB_ACTION_PATH}/.github/commands/"* .qwen/commands/
      env:
        GITHUB_ACTION_PATH: '${{ github.action_path }}'

    - name: 'Install pnpm'
      if: |-
        ${{ inputs.use_pnpm == 'true' }}
      uses: 'pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061' # ratchet:pnpm/action-setup@v4
      with:
        version: 10

    - name: 'Install Qwen Code'
      id: 'install'
      env:
        QWEN_CLI_VERSION: '${{ inputs.qwen_cli_version }}'
        EXTENSIONS: '${{ inputs.extensions }}'
        USE_PNPM: '${{ inputs.use_pnpm }}'
      shell: 'bash'
      run: |-
        set -euo pipefail

        VERSION_INPUT="${QWEN_CLI_VERSION:-latest}"

        if [[ "${VERSION_INPUT}" == "latest" || "${VERSION_INPUT}" == "preview" || "${VERSION_INPUT}" == "nightly" || "${VERSION_INPUT}" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9\.-]+)?(\+[a-zA-Z0-9\.-]+)?$ ]]; then
          echo "Installing Qwen Code from npm: @qwen-code/qwen-code@${VERSION_INPUT}"
          if [[ "${USE_PNPM}" == "true" ]]; then
            pnpm add --silent --global @qwen-code/qwen-code@"${VERSION_INPUT}"
          else
            npm install --silent --no-audit --prefer-offline --global @qwen-code/qwen-code@"${VERSION_INPUT}"
          fi
        else
          echo "Installing Qwen Code from GitHub: github:QwenLM/qwen-code#${VERSION_INPUT}"
          git clone https://github.com/QwenLM/qwen-code.git
          cd qwen-code
          git checkout "${VERSION_INPUT}"
          npm install
          npm run bundle
          npm install --silent --no-audit --prefer-offline --global .
        fi
        echo "Verifying installation:"
        if command -v qwen >/dev/null 2>&1; then
          qwen --version || echo "Qwen Code installed successfully (version command not available)"
        else
          echo "Error: Qwen Code not found in PATH"
          exit 1
        fi
        if [[ -n "${EXTENSIONS}" ]]; then
          echo "Installing Qwen Code extensions:"
          echo "${EXTENSIONS}" | jq -r '.[]' | while IFS= read -r extension; do
            extension=$(echo "${extension}" | xargs)
            if [[ -n "${extension}" ]]; then
              echo "Installing ${extension}..."
              echo "Y" | qwen extensions install "${extension}"
            fi
          done
        fi

    - name: 'Run Qwen Code'
      id: 'qwen_run'
      shell: 'bash'
      run: |-
        set -euo pipefail

        # Create a temporary directory for storing the output, and ensure it's
        # cleaned up later
        TEMP_STDOUT="$(mktemp -p "${RUNNER_TEMP}" qwen-out.XXXXXXXXXX)"
        TEMP_STDERR="$(mktemp -p "${RUNNER_TEMP}" qwen-err.XXXXXXXXXX)"
        function cleanup {
          rm -f "${TEMP_STDOUT}" "${TEMP_STDERR}"
        }
        trap cleanup EXIT

        # Keep track of whether we've failed
        FAILED=false

        # Run Qwen Code with the provided prompt, using JSON output format
        if [[ "${DEBUG}" = true ]]; then
          echo "::warning::Qwen Code debug logging is enabled. This will stream responses, which could reveal sensitive information if processed with untrusted inputs."
        fi

        # Build auth type flag if using OAuth
        AUTH_TYPE_FLAG=""
        if [[ "${USE_OAUTH}" == "true" ]]; then
          AUTH_TYPE_FLAG="--auth-type qwen-oauth"
        fi

        # We capture stdout (JSON) to TEMP_STDOUT and stderr to TEMP_STDERR
        if ! qwen --yolo ${AUTH_TYPE_FLAG} --prompt "${PROMPT}" --channel=CI --output-format json 2> "${TEMP_STDERR}" 1> "${TEMP_STDOUT}"; then
          FAILED=true
        fi

        if [[ "${DEBUG}" = true ]]; then
          echo "::: Start Qwen Code STDOUT :::"
          cat "${TEMP_STDOUT}"
          echo "::: End Qwen Code STDOUT :::"
        fi

        # Create the artifacts directory and copy full logs
        mkdir -p qwen-artifacts
        cp "${TEMP_STDOUT}" qwen-artifacts/stdout.log
        cp "${TEMP_STDERR}" qwen-artifacts/stderr.log
        if [[ -f .qwen/telemetry.log ]]; then
          cp .qwen/telemetry.log qwen-artifacts/telemetry.log
        else
          # Create an empty file so the artifact upload doesn't fail if telemetry is missing
          touch qwen-artifacts/telemetry.log
        fi

        # Parse JSON output to extract response and errors
        # The Qwen Code outputs an array of event objects, extract assistant message content
        RESPONSE=""
        ERROR_JSON=""
        if jq -e . "${TEMP_STDOUT}" >/dev/null 2>&1; then
           # Extract the text from assistant message content
           RESPONSE=$(jq -r '[.[] | select(.type == "assistant")] | last | .message.content[] | select(.type == "text") | .text' "${TEMP_STDOUT}")
        fi
        
        if jq -e . "${TEMP_STDERR}" >/dev/null 2>&1; then
           ERROR_JSON=$(jq -c '.error // empty' "${TEMP_STDERR}")
        fi
        if ! jq -e . "${TEMP_STDOUT}" >/dev/null 2>&1; then
          echo "::warning::Qwen Code stdout was not valid JSON"
        fi
        if [[ -s "${TEMP_STDERR}" ]] && ! jq -e . "${TEMP_STDERR}" >/dev/null 2>&1; then
          echo "::warning::Qwen Code stderr was not empty but not valid JSON"
        fi


        # Set the captured response as a step output, supporting multiline
        echo "qwen_response<<EOF" >> "${GITHUB_OUTPUT}"
        if [[ -n "${RESPONSE}" ]]; then
          echo "${RESPONSE}" >> "${GITHUB_OUTPUT}"
        else
          cat "${TEMP_STDOUT}" >> "${GITHUB_OUTPUT}"
        fi
        echo "EOF" >> "${GITHUB_OUTPUT}"

        # Set the captured errors as a step output, supporting multiline
        echo "qwen_errors<<EOF" >> "${GITHUB_OUTPUT}"
        if [[ -n "${ERROR_JSON}" ]]; then
          echo "${ERROR_JSON}" >> "${GITHUB_OUTPUT}"
        else
          cat "${TEMP_STDERR}" >> "${GITHUB_OUTPUT}"
        fi
        echo "EOF" >> "${GITHUB_OUTPUT}"

        if [[ "${FAILED}" = true ]]; then
          # If we have a structured error from JSON, use it for the error message
          if [[ -n "${ERROR_JSON}" ]]; then
             ERROR_MSG=$(jq -r '.message // .' <<< "${ERROR_JSON}")
             echo "::error title=Qwen Code execution failed::${ERROR_MSG}"
          fi
          echo "::: Start Qwen Code STDERR :::"
          cat "${TEMP_STDERR}"
          echo "::: End Qwen Code STDERR :::"
          exit 1
        fi
      env:
        DEBUG: '${{ fromJSON(inputs.qwen_debug || false) }}'
        USE_OAUTH: '${{ inputs.use_oauth }}'
        OPENAI_API_KEY: '${{ inputs.use_oauth != ''true'' && inputs.openai_api_key || '''' }}'
        OPENAI_BASE_URL: ${{ inputs.use_oauth != 'true' && inputs.openai_base_url || '' }}
        OPENAI_MODEL: ${{ inputs.use_oauth != 'true' && inputs.openai_model || 'qwen-coder-plus-latest' }}
        SURFACE: 'GitHub'
        PROMPT: '${{ inputs.prompt }}'
        GH_WORKFLOW_NAME: '${{ steps.sanitize_workflow_name.outputs.gh_workflow_name }}'

    - name: 'Upload Qwen Code outputs'
      if: |-
        ${{ inputs.upload_artifacts == 'true' }}
      uses: 'actions/upload-artifact@v4' # ratchet:exclude
      with:
        name: 'qwen-output'
        path: 'qwen-artifacts/'

branding:
  icon: 'terminal'
  color: 'blue'
