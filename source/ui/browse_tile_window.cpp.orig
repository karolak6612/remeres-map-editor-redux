//////////////////////////////////////////////////////////////////////
// This file is part of Remere's Map Editor
//////////////////////////////////////////////////////////////////////
// Remere's Map Editor is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Remere's Map Editor is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
//////////////////////////////////////////////////////////////////////

#include "map/tile_operations.h"
#include "app/main.h"

#include "map/map.h"
#include "ui/gui.h"
#include "brushes/raw/raw_brush.h"
#include "map/tile.h"
#include "rendering/core/graphics.h"
#include "ui/gui.h"
#include <wx/listbox.h>
#include "ui/browse_tile_window.h"
#include "util/image_manager.h"
#include "util/nanovg_listbox.h"
#include <glad/glad.h>
#include <format>
#include <nanovg.h>

// ============================================================================
//

class BrowseTileGridCanvas : public NanoVGCanvas {
public:
	BrowseTileGridCanvas(wxWindow* parent, wxWindowID id, Tile* tile);
	~BrowseTileGridCanvas();

	Item* GetSelectedItem();
	void RemoveSelected();

	void SetSelection(int index);
	void ClearSelection();

	size_t GetItemCount() const { return items.size(); }
	int GetSelectedCount() const { return m_selection == -1 ? 0 : 1; }

protected:
	void OnNanoVGPaint(NVGcontext* vg, int width, int height) override;
	wxSize DoGetBestClientSize() const override;

	void OnSize(wxSizeEvent& event);
	void OnMouseDown(wxMouseEvent& event);
	void OnMotion(wxMouseEvent& event);
	void OnLeave(wxMouseEvent& event);

	void UpdateLayout();
	int HitTest(int x, int y) const;
	wxRect GetItemRect(int index) const;

	void UpdateItems();

	using ItemsMap = std::vector<Item*>;
	ItemsMap items;
	Tile* edit_tile;

	int m_selection;
	int m_hoverIndex;
	int m_columns;
	int m_itemSize;
	int m_padding;
};

BrowseTileGridCanvas::BrowseTileGridCanvas(wxWindow* parent, wxWindowID id, Tile* tile) :
	NanoVGCanvas(parent, id, wxVSCROLL | wxWANTS_CHARS),
	edit_tile(tile),
	m_selection(-1),
	m_hoverIndex(-1),
	m_columns(1),
	m_itemSize(32),
	m_padding(8) {
	SetMinSize(FromDIP(wxSize(200, 180)));

	Bind(wxEVT_SIZE, &BrowseTileGridCanvas::OnSize, this);
	Bind(wxEVT_LEFT_DOWN, &BrowseTileGridCanvas::OnMouseDown, this);
	Bind(wxEVT_LEFT_DCLICK, &BrowseTileGridCanvas::OnMouseDown, this);
	Bind(wxEVT_MOTION, &BrowseTileGridCanvas::OnMotion, this);
	Bind(wxEVT_LEAVE_WINDOW, &BrowseTileGridCanvas::OnLeave, this);

	UpdateItems();
}

BrowseTileGridCanvas::~BrowseTileGridCanvas() {}

void BrowseTileGridCanvas::UpdateLayout() {
	int width = GetClientSize().x;
	if (width <= 0) width = 200;

	m_columns = std::max(1, (width - m_padding) / (m_itemSize + m_padding));
	int count = std::max(1, static_cast<int>(GetItemCount()));

	int rows = (count + m_columns - 1) / m_columns;
	int contentHeight = rows * (m_itemSize + m_padding) + m_padding;

	UpdateScrollbar(contentHeight);
}

wxSize BrowseTileGridCanvas::DoGetBestClientSize() const {
	return FromDIP(wxSize(200, 180));
}

int BrowseTileGridCanvas::HitTest(int x, int y) const {
	int scrollPos = GetScrollPosition();
	int realY = y + scrollPos;
	int col = (x - m_padding) / (m_itemSize + m_padding);
	int row = (realY - m_padding) / (m_itemSize + m_padding);

	if (col < 0 || col >= m_columns || row < 0) {
		return -1;
	}

	int index = row * m_columns + col;
	if (index < static_cast<int>(GetItemCount())) {
		wxRect r = GetItemRect(index);
		r.y -= scrollPos; // Convert back to local
		if (r.Contains(x, y)) {
			return index;
		}
	}
	return -1;
}

wxRect BrowseTileGridCanvas::GetItemRect(int index) const {
	int row = index / m_columns;
	int col = index % m_columns;
	return wxRect(
		m_padding + col * (m_itemSize + m_padding),
		m_padding + row * (m_itemSize + m_padding),
		m_itemSize,
		m_itemSize
	);
}

void BrowseTileGridCanvas::OnSize(wxSizeEvent& event) {
	UpdateLayout();
	Refresh();
	event.Skip();
}

void BrowseTileGridCanvas::OnMouseDown(wxMouseEvent& event) {
	int index = HitTest(event.GetX(), event.GetY());
	if (index != -1) {
		SetSelection(index);
		wxCommandEvent cmd(wxEVT_LISTBOX, GetId());
		cmd.SetEventObject(this);
		cmd.SetInt(index);
		GetEventHandler()->ProcessEvent(cmd);
	}
	event.Skip();
}

void BrowseTileGridCanvas::OnMotion(wxMouseEvent& event) {
	int index = HitTest(event.GetX(), event.GetY());
	if (index != m_hoverIndex) {
		m_hoverIndex = index;
		if (m_hoverIndex != -1) {
			SetCursor(wxCursor(wxCURSOR_HAND));
			SetToolTip(std::format("{} - {}", items[m_hoverIndex]->getID(), items[m_hoverIndex]->getName()));
		} else {
			SetCursor(wxNullCursor);
			SetToolTip("");
		}
		Refresh();
	}
	event.Skip();
}

void BrowseTileGridCanvas::OnLeave(wxMouseEvent& event) {
	if (m_hoverIndex != -1) {
		m_hoverIndex = -1;
		Refresh();
	}
	event.Skip();
}

void BrowseTileGridCanvas::OnNanoVGPaint(NVGcontext* vg, int width, int height) {
	int scrollPos = GetScrollPosition();
	int rowHeight = m_itemSize + m_padding;
	int startRow = scrollPos / rowHeight;
	int endRow = (scrollPos + height + rowHeight - 1) / rowHeight;
	int startIdx = startRow * m_columns;
	int endIdx = std::min(static_cast<int>(items.size()), (endRow + 1) * m_columns);

	for (int i = startIdx; i < endIdx; ++i) {
		if (i < 0) continue;

		wxRect r = GetItemRect(i);
		float x = r.x;
		float y = r.y;
		float w = r.width;
		float h = r.height;

		bool isSelected = (i == m_selection);
		bool isHovered = (i == m_hoverIndex);

		nvgBeginPath(vg);
		nvgRoundedRect(vg, x, y, w, h, 4.0f);
		if (isSelected) {
			wxColour selCol = Theme::Get(Theme::Role::Accent);
			nvgFillColor(vg, nvgRGBA(selCol.Red(), selCol.Green(), selCol.Blue(), 200));
		} else if (isHovered) {
			wxColour hoverCol = Theme::Get(Theme::Role::CardBaseHover);
			nvgFillColor(vg, nvgRGBA(hoverCol.Red(), hoverCol.Green(), hoverCol.Blue(), 255));
		} else {
			wxColour baseCol = Theme::Get(Theme::Role::CardBase);
			nvgFillColor(vg, nvgRGBA(baseCol.Red(), baseCol.Green(), baseCol.Blue(), 255));
		}
		nvgFill(vg);

		if (isSelected) {
			nvgBeginPath(vg);
			nvgRoundedRect(vg, x + 0.5f, y + 0.5f, w - 1, h - 1, 4.0f);
			wxColour accentCol = Theme::Get(Theme::Role::Accent);
			nvgStrokeColor(vg, nvgRGBA(accentCol.Red(), accentCol.Green(), accentCol.Blue(), 255));
			nvgStrokeWidth(vg, 2.0f);
			nvgStroke(vg);
		}

		Item* item = items[i];
		Sprite* sprite = g_gui.gfx.getSprite(item->getClientID());
		if (sprite) {
			int tex = GetOrCreateSpriteTexture(vg, sprite);
			if (tex > 0) {
				int tw, th;
				nvgImageSize(vg, tex, &tw, &th);
				float scale = std::min(w / tw, h / th);
				if (scale > 1.0f && std::max(tw, th) >= 32) scale = 1.0f;
				float dw = tw * scale;
				float dh = th * scale;
				float dx = x + (w - dw) / 2.0f;
				float dy = y + (h - dh) / 2.0f;

				NVGpaint imgPaint = nvgImagePattern(vg, dx, dy, dw, dh, 0.0f, tex, 1.0f);
				nvgBeginPath(vg);
				nvgRect(vg, dx, dy, dw, dh);
				nvgFillPaint(vg, imgPaint);
				nvgFill(vg);
			}
		}
	}
}

Item* BrowseTileGridCanvas::GetSelectedItem() {
	if (GetItemCount() == 0 || GetSelectedCount() == 0) {
		return nullptr;
	}

	return TileOperations::getTopSelectedItem(edit_tile);
}

void BrowseTileGridCanvas::RemoveSelected() {
	if (GetItemCount() == 0 || GetSelectedCount() == 0) {
		return;
	}

	ClearSelection();
	items.clear();

	// Delete the items from the tile
	auto tile_selection = TileOperations::popSelectedItems(edit_tile, true);
	// items are automatically deleted when tile_selection goes out of scope

	UpdateItems();
	Refresh();
}

void BrowseTileGridCanvas::SetSelection(int index) {
	if (m_selection != -1 && (size_t)m_selection < items.size()) {
		items[m_selection]->deselect();
	}
	m_selection = index;
	if (m_selection != -1 && (size_t)m_selection < items.size()) {
		items[m_selection]->select();
	}

	if (index >= 0 && index < static_cast<int>(items.size())) {
		wxRect rect = GetItemRect(index);
		int scrollPos = GetScrollPosition();
		int clientH = GetClientSize().y;

		if (rect.y < scrollPos) {
			SetScrollPosition(rect.y - m_padding);
		} else if (rect.y + rect.height > scrollPos + clientH) {
			SetScrollPosition(rect.y + rect.height - clientH + m_padding);
		}
	}
	Refresh();
}

void BrowseTileGridCanvas::ClearSelection() {
	for (Item* item : items) {
		item->deselect();
	}
	m_selection = -1;
	Refresh();
}

void BrowseTileGridCanvas::UpdateItems() {
	items.clear();
	items.reserve(edit_tile->items.size() + (edit_tile->ground ? 1 : 0));
	for (auto it = edit_tile->items.rbegin(); it != edit_tile->items.rend(); ++it) {
		items.push_back(it->get());
	}

	if (edit_tile->ground) {
		items.push_back(edit_tile->ground.get());
	}

	UpdateLayout();
}

// ============================================================================
//

BrowseTileWindow::BrowseTileWindow(wxWindow* parent, Tile* tile, wxPoint position /* = wxDefaultPosition */) :
	wxDialog(parent, wxID_ANY, "Browse Field", position, FROM_DIP(parent, wxSize(600, 400)), wxCAPTION | wxCLOSE_BOX | wxRESIZE_BORDER) {
	wxSizer* sizer = newd wxBoxSizer(wxVERTICAL);
	item_list = newd BrowseTileGridCanvas(this, wxID_ANY, tile);
	sizer->Add(item_list, wxSizerFlags(1).Expand());

	wxString pos;
	pos << "x=" << tile->getX() << ",  y=" << tile->getY() << ",  z=" << tile->getZ();

	wxSizer* infoSizer = newd wxBoxSizer(wxVERTICAL);
	wxBoxSizer* buttons = newd wxBoxSizer(wxHORIZONTAL);
	delete_button = newd wxButton(this, wxID_REMOVE, "Delete");
	delete_button->SetBitmap(IMAGE_MANAGER.GetBitmapBundle(ICON_TRASH_CAN));
	delete_button->SetToolTip("Delete selected item");
	delete_button->Enable(false);
	buttons->Add(delete_button);
	buttons->AddSpacer(5);
	select_raw_button = newd wxButton(this, wxID_FIND, "Select RAW");
	select_raw_button->SetBitmap(IMAGE_MANAGER.GetBitmapBundle(ICON_SEARCH));
	select_raw_button->SetToolTip("Select this item in RAW palette");
	select_raw_button->Enable(false);
	buttons->Add(select_raw_button);
	infoSizer->Add(buttons);
	infoSizer->AddSpacer(5);
	infoSizer->Add(newd wxStaticText(this, wxID_ANY, "Position:  " + pos), wxSizerFlags(0).Left());
	infoSizer->Add(item_count_txt = newd wxStaticText(this, wxID_ANY, "Item count:  " + i2ws(item_list->GetItemCount())), wxSizerFlags(0).Left());
	infoSizer->Add(newd wxStaticText(this, wxID_ANY, "Protection zone:  " + b2yn(tile->isPZ())), wxSizerFlags(0).Left());
	infoSizer->Add(newd wxStaticText(this, wxID_ANY, "No PvP:  " + b2yn(tile->getMapFlags() & TILESTATE_NOPVP)), wxSizerFlags(0).Left());
	infoSizer->Add(newd wxStaticText(this, wxID_ANY, "No logout:  " + b2yn(tile->getMapFlags() & TILESTATE_NOLOGOUT)), wxSizerFlags(0).Left());
	infoSizer->Add(newd wxStaticText(this, wxID_ANY, "PvP zone:  " + b2yn(tile->getMapFlags() & TILESTATE_PVPZONE)), wxSizerFlags(0).Left());
	infoSizer->Add(newd wxStaticText(this, wxID_ANY, "House:  " + b2yn(tile->isHouseTile())), wxSizerFlags(0).Left());

	sizer->Add(infoSizer, wxSizerFlags(0).Left().DoubleBorder());

	// OK/Cancel buttons
	wxSizer* btnSizer = newd wxBoxSizer(wxHORIZONTAL);
	auto okBtn = newd wxButton(this, wxID_OK, "OK");
	okBtn->SetBitmap(IMAGE_MANAGER.GetBitmapBundle(ICON_CHECK));
	okBtn->SetToolTip("Confirm selection");
	btnSizer->Add(okBtn, wxSizerFlags(0).Center());
	auto cancelBtn = newd wxButton(this, wxID_CANCEL, "Cancel");
	cancelBtn->SetBitmap(IMAGE_MANAGER.GetBitmapBundle(ICON_XMARK));
	cancelBtn->SetToolTip("Cancel");
	btnSizer->Add(cancelBtn, wxSizerFlags(0).Center());
	sizer->Add(btnSizer, wxSizerFlags(0).Center().DoubleBorder());

	SetSizerAndFit(sizer);

	// Connect Events
	item_list->Bind(wxEVT_LISTBOX, &BrowseTileWindow::OnItemSelected, this);
	delete_button->Bind(wxEVT_BUTTON, &BrowseTileWindow::OnClickDelete, this);
	select_raw_button->Bind(wxEVT_BUTTON, &BrowseTileWindow::OnClickSelectRaw, this);
	Bind(wxEVT_BUTTON, &BrowseTileWindow::OnClickOK, this, wxID_OK);
	Bind(wxEVT_BUTTON, &BrowseTileWindow::OnClickCancel, this, wxID_CANCEL);
}

BrowseTileWindow::~BrowseTileWindow() {
}

void BrowseTileWindow::OnItemSelected(wxCommandEvent& WXUNUSED(event)) {
	const size_t count = item_list->GetSelectedCount();
	delete_button->Enable(count != 0);
	select_raw_button->Enable(count == 1);
}

void BrowseTileWindow::OnClickDelete(wxCommandEvent& WXUNUSED(event)) {
	item_list->RemoveSelected();
	item_count_txt->SetLabelText("Item count:  " + i2ws(item_list->GetItemCount()));
}

void BrowseTileWindow::OnClickSelectRaw(wxCommandEvent& WXUNUSED(event)) {
	Item* item = item_list->GetSelectedItem();
	if (item && item->getRAWBrush()) {
		g_gui.SelectBrush(item->getRAWBrush(), TILESET_RAW);
	}

	EndModal(1);
}

void BrowseTileWindow::OnClickOK(wxCommandEvent& WXUNUSED(event)) {
	EndModal(1);
}

void BrowseTileWindow::OnClickCancel(wxCommandEvent& WXUNUSED(event)) {
	EndModal(0);
}
